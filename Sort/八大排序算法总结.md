# 排序

## 1.介绍
### 分类
排序大的分类可以分为两种，内排序和外排序。在排序过程中，全部记录存放在内存，则称为内排序，如果排序过程中需要使用外存，则称为外排序。主要需要理解的都是内排序算法:
* 插入排序:直接插入排序、希尔排序、二分插入排序

* 选择排序:简单选择排序、堆排序

* 交换排序:冒泡排序、快速排序

* 归并排序:

* 基数排序:


性能对比

稳定性:就是能保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同。即如果Ai = Aj,Ai原来在Aj位置前，排序后Ai仍然是在Aj位置前。

* 不稳定：简单选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法

* 稳定：冒泡排序、直接插入排序、二分插入排序、归并排序和基数排序都是稳定的排序算法.

时间复杂度：一个算法执行所耗费的时间。

* O(nlog(n)):快速排序、归并排序、希尔排序、堆排序

* O(n^2):直接插入排序、简单选择排序、冒泡排序

* O(n):桶、箱、基数排序

空间复杂度：运行完一个程序所需要的内存大小

> 快速排序是目前基于比较的内部排序中最好的方法，其次是归并排序和希尔排序，堆排序在数据量很大时效果明显。当数据是随机分布是快速排序的平均时间最短。

![图1](https://github.com/HYQ2018/DataStructure/blob/master/Sort/conclue.png)


排序方法的选择：
1.数据规模很小：（插入、简单选择、冒泡）
* 数据基本有序时，可选用直接插入排序。
* 数据无序时，对稳定性不做要求可用简单选择排序。对稳定性有要求可用插入排序或冒泡排序。

2.数据规模一般(快速排序、归并排序)
*完全可以用内存空间，序列杂乱无序，对稳定性没有要求，用快速排序，但要付出log(N)的额外空间。
*序列本身可能有序，对稳定性有要求，空间允许下，可用归并排序。

3.数据规模很大（归并排序、桶）
* 对稳定性有要求，则可用用归并排序
* 对稳定性没要求，宜用堆排序

4.待排序序列基本有序：使用直接插入、冒泡

## 2.插入排序
  基本思想：一次遍历元素，在已排序的序列中找到合适的位置将当前的遍历的元素插入，直到所有元素都已排序。
  
  方法：直接插入排序、二分插入排序、希尔排序
 
 ### 2.1直接插入排序
 
 算法：
 * <1>从第一个元素开始，该元素可以认为已经排好序。
 * <2>取下一个元素，在已排序的序列从后先前扫描。
 * <3>找到一个位置插入该元素使得新序列有序：如果已排序元素大于新元素，则将该已排序元素后移。直到找到已排序的元素小于新元素，插入该位置。
 * <4>重复步骤2~3。
 
 时间复杂度：平均情况下O(n^2)
 * 最好情况：正序有序（[1,2,3,4,5,6,7,8,9]）.只需要比较n次,不需要移动。时间复杂度O(n)
 * 最坏情况：逆序有序([9,8,7,6,5,4,3,2,1]).这样每一个元素就需要比较n次，共n个元素，因此实际复杂度为O(n^2).
 
 * 稳定性：稳定。由算法思想易知，反向遍历已排序元素，若已排序元素小于等于当前元素，则将当前元素插入该已排序元素后的位置，因此相对顺序不变，插入排序是稳定的。

```
 #python实现
 def insert_sort(x):
    N = len(x)
    for i in range(1,N):
		j = i - 1
		key = x[i]
		while j>=0 and x[j] > key:
			x[j+1] = x[j]
			j = j -1
		x[j+1] = key
```
 


### 2.2希尔排序(shell sort)
基本思想：希尔排序也是一种插入排序方法，实际上是一种分组插入排序方法。先取定一个小雨n的整数d1作为第一个增量，这样可以把表的全部记录分为d1组：所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序；然后，取第二个增量d2(<d1),重复上述分组和排序，直至所取的增量dt=1(dt<dt-1<dt-2<...<d1),即所有记录放在同一组中进行直接插入排序。

希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。

时间复杂度：平均情况下(O(N*log(N)).
* 最好情况：由于希尔排序的好坏和步长d的选择（di到di+1的选择策略）有很多关系，因此，目前还没有得出最好的步长如何选择(现在有些比较好的选择了，但不确定是否是最好的)。所以，不知道最好的情况下的算法时间复杂度。  
* 最坏情况：O(N*logN)，最坏的情况下和平均情况下差不多。

* 稳定性：由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同趟的插入排序过程中，相同的元素可能在各自的插入排序中移动，最好其稳定性就会被打乱，所以shell排序是不稳定的。(有个猜测，方便记忆：一般来说，若存在不相邻元素间交换，则很可能是不稳定的排序。)

```
def shell_sort(x):
	d = len(x)//2
	while d>=1:
		for i in range(d,len(x)):
			key = x[i]
			j = i -d
			while j>=0 and x[j]>key:
				x[j+d] = x[j]
				j = j - d
			x[j+d] = key
		d = d//2
	
```

## 3.交换排序
### 3.1冒泡排序(Bubble Sort)
基本思想：通过无序区中相邻记录关键字间的比较和位置的交换，使得关键字最小的记录如气泡一般逐渐往上漂浮直至水面。

时间复杂度：平均O(n^2)

* 最好情况：正序有序，则只需要比较n次。为O(n).
* 最坏情况：逆序有序，则需要比较n(n-1)/2,故为O(n^2)

稳定性：稳定。排序过程中只交换相邻两个元素的位置。因此，当两个数相等时，是没有必要交换两个数的位置的。所以相对位置并没有改变，冒泡算法排序是稳定的。

算法描述：
* <1> 比较相邻的元素。如果第一个比第二个大，就交换它们两个。
* <2> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最好的元素应该会是最大的数。
* <3> 针对所有元素重复以上的步骤，除了最后一个。
* <4> 重复步骤1～3,知道排序完成。

```
def bubble_sort(x):
	N = len(x)
	flag = 0
	count = 0
	for i in range(N):
		for j in range(0,N-i-1):
			count = count + 1
			if x[j]>x[j+1]:
				x[j],x[j+1] = x[j+1],x[j]
				flag = 1
		print(count)
		if flag == 0:
			break
```
改进：设一标志变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位，故在进行下一趟排序时只要扫到pos位置即可。因为上一轮冒泡的最后一次交换说明该交换的元素是其位置以前的所有元素中最大的(毕竟是自己冒上来的)。下一趟找最大元素的冒泡从该位置开始即可，不必从头开始两两交换
```
def bubble_sort(x):
	N = len(x)
	flag = 0
	pos = 0
	i = N - 1
	count = 0
	while i >= 0:
		for j in range(0,i):
			count = count + 1
			if x[j]>x[j+1]:
				x[j],x[j+1] = x[j+1],x[j]
				flag = 1
				pos = j
		print(count)
		if flag == 0:
			break
		i = min(pos,i-1)
```

### 3.2快速排序(Quick Sort)
基本思想：由冒泡排序改进而来的。在带排序的n个记录中任取一个记录(通常取第一个记录),把该记录放入适当位置后，数据序列由此被划分为两部分。所有关键字比该记录关键字小的记录放置在前一部分，所有比它大的记录放置在后一部分，并把该记录排在这两部分的中间(称为该记录归位)。

核心思想：通过一趟排序将待排序记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续排序，以达到整个序列有序。

时间复杂度:O(Nlog(N))

* 最好的情况：因为每次都将序列分为两个部分(一般二分都复杂度和logN相关),故为O(NlogN)
* 最坏的情况：基本有序时，退化为冒泡排序，几乎要比较(N*N)次，故为O(N*N)

稳定性： 不稳定。由于每次都需要和中轴元素(不一定相邻)交换，因此原来的顺序就可能被打乱。快速排序是不稳定的。

算法描述：
* <1> 从数列中挑出一个元素，称为基准(pivot)
* <2>重新排列数列，所有比基准值小的摆在基准前面，所有比基准大的摆在基准的后面(相同的数可能到仁一边)。在这个分区完成后，该基准就处于数列的中间位置。这个称为分区(partition)操作。
* <3>递归地把小于基准元素的子数列和大于基准元素的子数序列排序。

```
def quick_sort(x,left,right):
	if left < right:
		mid = merge(x,left,right)
		quick_sort(x,left,mid-1)
		quick_sort(x,mid+1,right)

def merge(x,left,right):
	piovt = x[left]
	while left<right:
		while left < right and x[right] > piovt:
			right = right - 1
		x[left] = x[right]
		while left<right and x[left] <= piovt:
			left = left + 1
		x[right] = x[left]
	x[left] = piovt
	return left
```

## 选择排序
### 4.1简单选择排序
基本思想：首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。具体的做法是：选择最小元素与未排序部分的首部，使得序列的前面为有序。

时间复杂度：平均情况下：O(N^2)
* 最后情况：交换0次，但是每次都要寻找最小的元素，因此大约必须遍历N*N次，因此为O(N*N).减少了交换次数！
* 最好情况：平均情况下：O(N*N)

稳定性：不稳定。由于每次都是选取未排序序列A中最小的元素x与A中的第一个元素交换，因此夸距离了，很可能破坏了元素间的相对位置，因此选择排序是不稳定的！

算法描述：n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。
* <1>初始状态：无序区间为R[1...n],有序区为空；
* <2>第i趟排序(i=1,2,3...n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n].该趟排序从当前无序区中选出最小关键字的记录R[k],将它与无序区的第1个记录R交换，使R[1...i]和R[i+1...n]分别为新的有序区和无序区。
* <3>n-1趟结束，数组有序化了。

```
def select_sort(x):
	N = len(x)
	for i in range(N):
		for j in range(i+1,N):
			if x[j]<x[i]:
				x[i],x[j] = x[j],x[i]
```

### 4.2堆排序
基本思想：堆排序（Heapsort)是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的健值或索引总是小于(或者大与)它的父节点。用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大（或者最小）的记录。也就是说，以最小堆为例，根节点为最小元素，较大的节点偏向于分布在堆低附近。

时间复杂度:O(nlogn)。

稳定性：不稳定。

算法描述：
* <1>将初始待排序关键字序列(R1,R2,...Rn)构建成大顶堆，此堆为初始的无序区。
* <2>将堆顶元素R[1]与最好一个元素R[n]交换，此时得到新的无序区(R1,R2,...Rn-1)和新的有序区(Rn)
* <3>由于交换后新的堆顶元素R[1]可能违反堆的性质。因此需要对当前无序区(R1,R2,...Rn-1)调整为新堆，然后再次将R[1]与无序区最好一个元素交换，得到新的无序区(R1,R2,...,Rn-1)和新的有序区(Rn-1,Rn).不断重复此过程直到有序区的元素个数为n-1,则整个排序过程完成。

```
def adjust_head(x,i,size):
	lchild = i*2+1
	rchild = i*2+2
	max = i
	if i < size//2:
		if lchild < size and x[lchild] > x[max]:
			max = lchild
		if rchild < size and x[rchild] > x[max]:
			max = rchild
		if max != i:
			x[max],x[i] = x[i],x[max]
			adjust_head(x,max,size)

def build_heap(x):
    size = len(x)
    for i in range(0,int(size/2))[::-1]:
        print(i)
        adjust_head(x,i,size)

def sort_heap(x):
	build_heap(x)
	N = len(x)
	for i in range(N)[::-1]:
		x[0],x[i] = x[i],x[0]
		adjust_head(x,0,i)

```


## 归并排序
 基本思想：归并排序是一个典型的基于分治的递归算法。它不断地将原数组分成大小相等的两个子数组(可能相差1)，最好当划分为子数组的大小为1时，将划分的有序子数组合并成一个更大的有序数组。
 
 时间复杂度:O(NlogN),将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)
 
 稳定性：稳定的。
 
 算法描述：
 * <1>将原序列划分为两个子序列
 * <2>分别对两个子序列递归调用归并排序，使得它们有序。(具体地就是不断划分子序列直到长度为1)
 * <3>对两个有序的序列，合并它们为一个有序的序列。()
 
```
def merge_sort(x,low,high):
    if low <high:
        mid = (low+high)//2
        merge_sort(x,low,mid)
        merge_sort(x,mid+1,high)
        l = []
        i = low
        j = mid+1
        while i<=mid and j<=high:
            if x[i]<x[j]:
                l.append(x[i])
                i = i +1
            if x[j]<=x[i]:
                l.append(x[j])
                j = j+1
        while i<=mid:
            l.append(x[i])
            i = i+1
        while j<=high:
            l.append(x[j])
            j = j+1
        for k in range(low,high+1):
            x[k] = l[k-low]
```

## 基数排序
基本思想：基数排序是痛排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。
具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的前面补0.然后，从最低位开始，依次进行一次排序。

* 又分为LSD\MSD,从低位到高位，从高位到低位。
* 时间复杂度：O(N*digit)

* 空间复杂度：O(N)

* 稳定性：稳定

```
def radix_sort(x,d):
	for i in range(d):
		bucket = [[] for i1 in range(10)]
		for z in x:
			bucket[(z/(10**i))%10].append(z)
		x = [a1 for a2 in bucket for a1 in a2]
        print(x)
	return x
```
